/**
 * Comprehensive MINEDX Data Scraper - EVERYTHING Possible
 * Extracts ALL available data from MINEDX including hidden fields, API endpoints, and every data point
 */

import * as cheerio from 'cheerio';

// Comprehensive interfaces for ALL possible data
export interface ComprehensiveMinedxData {
  // Core Identifiers
  tenementNumber: string;
  tenementId?: string;
  projectCode?: string;
  projectId?: string;
  
  // Basic Tenement Data
  tenementType?: string;
  status?: string;
  appliedDate?: string;
  grantedDate?: string;
  expiryDate?: string;
  deathDate?: string;
  area?: number;
  areaUnits?: string;
  
  // Geographic Data
  coordinates?: {
    centroid?: { latitude: number; longitude: number };
    bounds?: { north: number; south: number; east: number; west: number };
    vertices?: Array<{ latitude: number; longitude: number }>;
  };
  mapSheetNumbers?: string[];
  locality?: string;
  region?: string;
  
  // Holders (Comprehensive)
  holders: Array<{
    holderName: string;
    holderType?: string;
    interest: string;
    percentage?: number;
    startDate?: string;
    endDate?: string;
    isActive?: boolean;
    address?: string;
    abn?: string;
    acn?: string;
  }>;
  
  // Sites (Complete Data)
  sites: Array<{
    siteName: string;
    siteCode: string;
    siteId?: string;
    siteType: string;
    siteSubtype?: string;
    siteStage?: string;
    siteStatus?: string;
    primaryClassification?: string;
    secondaryClassification?: string;
    coordinates?: { latitude?: number; longitude?: number };
    elevation?: number;
    startDate?: string;
    endDate?: string;
    projectCode?: string;
    projectName?: string;
    description?: string;
    operationType?: string;
    miningMethod?: string;
    targetDepth?: string;
    estimatedReserves?: string;
    geologicalSetting?: string;
    accessRoute?: string;
    infrastructure?: string[];
    environmentalConstraints?: string[];
    culturalHeritage?: string[];
  }>;
  
  // Projects (Everything)
  projects: Array<{
    projectName: string;
    projectCode: string;
    projectId?: string;
    shortName?: string;
    projectType?: string;
    projectStatus?: string;
    projectStage?: string;
    projectExplorationStage?: string;
    mineStage?: string;
    operationalStatus?: string;
    smallMiningOperation?: boolean;
    totalCurrentSites?: number;
    startDate?: string;
    endDate?: string;
    expectedDuration?: string;
    
    // Commodities (Detailed)
    primaryCommodity?: string;
    secondaryCommodities?: string[];
    commodityGroups?: string[];
    targetGrades?: Array<{
      commodity: string;
      grade: string;
      unit: string;
    }>;
    
    // Financial Data
    estimatedValue?: number;
    investmentAmount?: number;
    annualRevenue?: number;
    operatingCosts?: number;
    capitalExpenditure?: number;
    employmentNumbers?: number;
    economicImpact?: string;
    
    // Technical Data
    miningMethod?: string;
    processingMethod?: string;
    productionCapacity?: string;
    reserveEstimate?: string;
    resourceEstimate?: string;
    cutOffGrade?: string;
    stripRatio?: string;
    recoveryRate?: string;
    
    // Environmental & Social
    environmentalApprovals?: string[];
    socialLicence?: string;
    communityEngagement?: string[];
    indigenousHeritage?: string[];
    biodiversityImpacts?: string[];
    waterUsage?: string;
    energySource?: string;
    wasteManagement?: string;
    rehabilitation?: string;
    
    // Ownership & Management
    owners: Array<{
      ownerName: string;
      ownerType?: string;
      percentage?: number;
      startDate?: string;
      endDate?: string;
      role?: string;
      contactDetails?: string;
    }>;
    
    // Project Timeline & Events
    events: Array<{
      eventDate: string;
      eventType: string;
      description: string;
      source?: string;
      impact?: string;
      status?: string;
    }>;
    
    // Documentation & References
    attachments: Array<{
      fileName: string;
      fileType?: string;
      fileSize?: string;
      uploadDate?: string;
      description?: string;
      category?: string;
      url?: string;
    }>;
    
    alternativeNames?: string[];
    notes?: string[];
    tags?: string[];
    keywords?: string[];
  }>;
  
  // Environmental Data (Complete)
  environmentalRegistrations: Array<{
    registrationId?: string;
    registrationName?: string;
    registrationType?: string;
    registrationCategory?: string;
    registrationStatus?: string;
    applicationDate?: string;
    dateDecided?: string;
    expiryDate?: string;
    environmentalOperator?: string;
    conditions?: string[];
    monitoringRequirements?: string[];
    complianceStatus?: string;
    lastInspectionDate?: string;
    violations?: string[];
  }>;
  
  // Production Data (Comprehensive)
  production: Array<{
    startDate?: string;
    endDate?: string;
    productionPeriod?: string;
    product?: string;
    commodity?: string;
    quantity?: number;
    unit?: string;
    grade?: string;
    recoveryRate?: string;
    processingMethod?: string;
    destination?: string;
    marketValue?: number;
    royalties?: number;
    calculatedCommodity?: string;
    qualityMetrics?: Array<{
      metric: string;
      value: string;
      unit: string;
    }>;
  }>;
  
  // Information Sources (All References)
  informationSources: Array<{
    sourceType: string;
    title: string;
    identifier?: string;
    author?: string;
    date?: string;
    publisher?: string;
    url?: string;
    description?: string;
    reliability?: string;
    accessDate?: string;
  }>;
  
  // Geological Data (Complete)
  geologicalData?: {
    geology?: string;
    mineralogy?: string;
    stratigraphy?: string;
    structure?: string;
    alteration?: string;
    geophysics?: string;
    geochemistry?: string;
    hydrogeology?: string;
    geotechnical?: string;
    rockTypes?: string[];
    mineralAssemblages?: string[];
    structuralFeatures?: string[];
    alterationTypes?: string[];
  };
  
  // Compliance & Legal
  complianceData?: {
    permits?: Array<{
      permitType: string;
      permitNumber: string;
      issueDate: string;
      expiryDate: string;
      conditions: string[];
      status: string;
    }>;
    approvals?: Array<{
      approvalType: string;
      approvalNumber: string;
      issueDate: string;
      conditions: string[];
      status: string;
    }>;
    conditions?: string[];
    restrictions?: string[];
    obligations?: string[];
    penalties?: Array<{
      date: string;
      type: string;
      amount: number;
      reason: string;
      status: string;
    }>;
  };
  
  // Technical Reports & Studies
  technicalReports?: Array<{
    reportType: string;
    title: string;
    author: string;
    date: string;
    summary: string;
    findings: string[];
    recommendations: string[];
    url?: string;
  }>;
  
  // Market & Economic Data
  marketData?: {
    commodityPrices?: Array<{
      commodity: string;
      price: number;
      unit: string;
      date: string;
      source: string;
    }>;
    marketTrends?: string[];
    competitiveAnalysis?: string;
    supplyChain?: string[];
    customers?: string[];
    contracts?: Array<{
      contractType: string;
      counterparty: string;
      startDate: string;
      endDate: string;
      value: number;
      terms: string;
    }>;
  };
  
  // Infrastructure & Logistics
  infrastructure?: {
    access?: {
      roadAccess?: string;
      railAccess?: string;
      portAccess?: string;
      airportAccess?: string;
      distance?: string;
      condition?: string;
    };
    utilities?: {
      powerSupply?: string;
      waterSupply?: string;
      telecommunications?: string;
      gasSupply?: string;
    };
    facilities?: {
      processingPlant?: string;
      accommodation?: string;
      workshops?: string;
      offices?: string;
      storage?: string;
    };
    transport?: {
      haulageRoute?: string;
      transportMethod?: string;
      capacity?: string;
      costs?: string;
    };
  };
  
  // Risk Assessment
  riskAssessment?: {
    technicalRisks?: string[];
    environmentalRisks?: string[];
    socialRisks?: string[];
    economicRisks?: string[];
    regulatoryRisks?: string[];
    operationalRisks?: string[];
    mitigationStrategies?: Array<{
      risk: string;
      mitigation: string;
      effectiveness: string;
    }>;
  };
  
  // Metadata
  metadata: {
    lastScraped: string;
    minedxUrl: string;
    dataCompleteness: number;
    scrapingVersion: string;
    apiEndpoints?: string[];
    hiddenFields?: Array<{
      fieldName: string;
      value: string;
      source: string;
    }>;
  };
}

export class ComprehensiveMinedxScraper {
  private readonly baseUrl = 'https://minedx.dmirs.wa.gov.au';
  private readonly userAgent = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36';
  
  /**
   * Extract EVERYTHING possible from a tenement/project page
   */
  async scrapeEverything(tenementNumber: string): Promise<ComprehensiveMinedxData | null> {
    try {
      console.log(`üîç Comprehensive scraping for: ${tenementNumber}`);
      
      // Get both tenement and project data
      const tenementData = await this.scrapeTenementPage(tenementNumber);
      const projectData = await this.scrapeAllProjectPages(tenementNumber);
      const apiData = await this.scrapeApiEndpoints(tenementNumber);
      const hiddenData = await this.extractHiddenData(tenementNumber);
      
      // Merge all data sources
      const comprehensiveData = this.mergeAllDataSources(
        tenementData,
        projectData,
        apiData,
        hiddenData
      );
      
      return comprehensiveData;
      
    } catch (error) {
      console.error(`Error in comprehensive scraping for ${tenementNumber}:`, error);
      return null;
    }
  }
  
  private async scrapeTenementPage(tenementNumber: string): Promise<Partial<ComprehensiveMinedxData>> {
    const url = `${this.baseUrl}/Web/tenements/details/${encodeURIComponent(tenementNumber)}`;
    const response = await fetch(url, { headers: { 'User-Agent': this.userAgent } });
    const html = await response.text();
    const $ = cheerio.load(html);

    return {
      tenementNumber,
      tenementType: this.extractValue($, 'Type'),
      status: this.extractValue($, 'Status'),
      appliedDate: this.extractValue($, 'Applied Date'),
      grantedDate: this.extractValue($, 'Granted Date'),
      expiryDate: this.extractValue($, 'Expiry Date'),
      deathDate: this.extractValue($, 'Death Date'),
      area: this.parseNumber(this.extractValue($, 'Area')),
      holders: this.extractHolders($),
      sites: this.extractSites($),
      projects: this.extractProjects($),
      environmentalRegistrations: this.extractEnvironmentalData($),
      production: this.extractProductionData($),
      informationSources: this.extractInformationSources($),
      coordinates: this.extractCoordinates($),
      geologicalData: this.extractGeologicalData($),
      complianceData: this.extractComplianceData($),
      metadata: {
        lastScraped: new Date().toISOString(),
        minedxUrl: url,
        dataCompleteness: 0,
        scrapingVersion: '2.0-comprehensive'
      }
    };
  }
  
  private async scrapeAllProjectPages(tenementNumber: string): Promise<any[]> {
    const projectData = [];
    
    // First get project codes from tenement page
    const tenementUrl = `${this.baseUrl}/Web/tenements/details/${encodeURIComponent(tenementNumber)}`;
    const response = await fetch(tenementUrl, { headers: { 'User-Agent': this.userAgent } });
    const html = await response.text();
    const $ = cheerio.load(html);
    
    const projectCodes = this.extractProjectCodes($);
    
    // Scrape each project page in detail
    for (const projectCode of projectCodes) {
      try {
        const projectUrl = `${this.baseUrl}/Web/projects/details/${encodeURIComponent(projectCode)}`;
        const projectResponse = await fetch(projectUrl, { headers: { 'User-Agent': this.userAgent } });
        const projectHtml = await projectResponse.text();
        const project$ = cheerio.load(projectHtml);
        
        const projectDetails = {
          projectCode,
          projectName: this.extractValue(project$, 'Project Name') || project$('h1').text().trim(),
          shortName: this.extractValue(project$, 'Short Name'),
          projectStatus: this.extractValue(project$, 'Project Status'),
          projectStage: this.extractValue(project$, 'Project Exploration Stage'),
          mineStage: this.extractValue(project$, 'Project Mine Stage'),
          smallMiningOperation: this.extractValue(project$, 'Small Mining Operation') === 'Yes',
          startDate: this.extractValue(project$, 'Start Date'),
          endDate: this.extractValue(project$, 'End Date'),
          
          // Extract all project-specific data
          owners: this.extractProjectOwners(project$),
          events: this.extractProjectEvents(project$),
          attachments: this.extractProjectAttachments(project$),
          alternativeNames: this.extractAlternativeNames(project$),
          notes: this.extractProjectNotes(project$),
          commodityGroups: this.extractCommodityGroups(project$),
          technicalReports: this.extractTechnicalReports(project$),
          marketData: this.extractMarketData(project$),
          infrastructure: this.extractInfrastructureData(project$),
          riskAssessment: this.extractRiskAssessment(project$)
        };
        
        projectData.push(projectDetails);
        
        // Respectful delay
        await new Promise(resolve => setTimeout(resolve, 1000));
        
      } catch (error) {
        console.error(`Error scraping project ${projectCode}:`, error);
      }
    }
    
    return projectData;
  }
  
  private async scrapeApiEndpoints(tenementNumber: string): Promise<any> {
    const apiData: any = {};
    
    // Discover and scrape potential API endpoints
    const potentialEndpoints = [
      `/api/tenements/${tenementNumber}`,
      `/api/tenements/${tenementNumber}/sites`,
      `/api/tenements/${tenementNumber}/projects`,
      `/api/tenements/${tenementNumber}/environmental`,
      `/api/tenements/${tenementNumber}/production`,
      `/api/projects/search?tenement=${tenementNumber}`,
      `/api/sites/search?tenement=${tenementNumber}`,
      `/api/holders/search?tenement=${tenementNumber}`
    ];
    
    for (const endpoint of potentialEndpoints) {
      try {
        const url = `${this.baseUrl}${endpoint}`;
        const response = await fetch(url, {
          headers: {
            'User-Agent': this.userAgent,
            'Accept': 'application/json, application/xml, text/html'
          }
        });
        
        if (response.ok) {
          const contentType = response.headers.get('content-type');
          let data;
          
          if (contentType?.includes('application/json')) {
            data = await response.json();
          } else if (contentType?.includes('application/xml')) {
            data = await response.text();
          } else {
            data = await response.text();
          }
          
          apiData[endpoint] = {
            data,
            contentType,
            status: response.status,
            headers: Object.fromEntries(response.headers.entries())
          };
        }
      } catch (error) {
        // Endpoint doesn't exist or is not accessible
        console.log(`API endpoint ${endpoint} not available`);
      }
    }
    
    return apiData;
  }
  
  private async extractHiddenData(tenementNumber: string): Promise<any> {
    const hiddenData: any = {};
    
    try {
      const url = `${this.baseUrl}/Web/tenements/details/${encodeURIComponent(tenementNumber)}`;
      const response = await fetch(url, { headers: { 'User-Agent': this.userAgent } });
      const html = await response.text();
      const $ = cheerio.load(html);
      
      // Extract hidden form fields
      const hiddenFields: Array<{fieldName: string; value: string; source: string}> = [];
      
      $('input[type="hidden"]').each((_, element) => {
        const name = $(element).attr('name');
        const value = $(element).attr('value');
        if (name && value) {
          hiddenFields.push({
            fieldName: name,
            value: value,
            source: 'hidden-input'
          });
        }
      });
      
      // Extract data from JavaScript variables
      const scriptTags = $('script').toArray();
      for (const script of scriptTags) {
        const scriptContent = $(script).html() || '';
        
        // Look for common JavaScript data patterns
        const dataPatterns = [
          /var\s+(\w+)\s*=\s*([^;]+);/g,
          /const\s+(\w+)\s*=\s*([^;]+);/g,
          /let\s+(\w+)\s*=\s*([^;]+);/g,
          /(\w+)\s*:\s*([^,}]+)/g
        ];
        
        for (const pattern of dataPatterns) {
          let match;
          while ((match = pattern.exec(scriptContent)) !== null) {
            try {
              hiddenFields.push({
                fieldName: match[1],
                value: match[2].trim(),
                source: 'javascript-variable'
              });
            } catch (e) {
              // Skip invalid matches
            }
          }
        }
      }
      
      // Extract data attributes
      $('[data-*]').each((_, element) => {
        const attributes = (element as any).attribs || {};
        for (const [key, value] of Object.entries(attributes)) {
          if (key.startsWith('data-') && typeof value === 'string') {
            hiddenFields.push({
              fieldName: key,
              value: value,
              source: 'data-attribute'
            });
          }
        }
      });
      
      // Extract meta tags
      $('meta').each((_, element) => {
        const name = $(element).attr('name') || $(element).attr('property');
        const content = $(element).attr('content');
        if (name && content) {
          hiddenFields.push({
            fieldName: name,
            value: content,
            source: 'meta-tag'
          });
        }
      });
      
      hiddenData.hiddenFields = hiddenFields;
      
      // Extract any embedded JSON data
      const jsonMatches = html.match(/\{[^{}]*(?:\{[^{}]*\}[^{}]*)*\}/g) || [];
      const validJsonData = [];
      
      for (const jsonMatch of jsonMatches) {
        try {
          const parsed = JSON.parse(jsonMatch);
          validJsonData.push(parsed);
        } catch (e) {
          // Not valid JSON, skip
        }
      }
      
      hiddenData.embeddedJson = validJsonData;
      
    } catch (error) {
      console.error('Error extracting hidden data:', error);
    }
    
    return hiddenData;
  }
  
  private mergeAllDataSources(...sources: any[]): ComprehensiveMinedxData {
    const merged = sources.reduce((acc, source) => ({ ...acc, ...source }), {});
    
    // Calculate data completeness score
    const totalFields = Object.keys(merged).length;
    const populatedFields = Object.values(merged).filter(value => 
      value !== null && value !== undefined && value !== '' && 
      (Array.isArray(value) ? value.length > 0 : true)
    ).length;
    
    merged.metadata = {
      ...merged.metadata,
      dataCompleteness: (populatedFields / totalFields) * 100
    };
    
    return merged as ComprehensiveMinedxData;
  }
  
  // Helper methods for data extraction
  private extractValue($: any, label: string): string | undefined {
    let value: string | undefined;
    
    // Try multiple patterns to find the value
    $('table tr').each((_: number, row: any) => {
      const $row = $(row);
      const cellLabel = $row.find('td:first-child').text().trim();
      if (cellLabel.toLowerCase().includes(label.toLowerCase())) {
        value = $row.find('td:last-child').text().trim();
        return false; // Break the loop
      }
    });
    
    // Try other patterns if not found in table
    if (!value) {
      $(`dt:contains("${label}")`).each((_, dt) => {
        value = $(dt).next('dd').text().trim();
        return false;
      });
    }
    
    return value || undefined;
  }
  
  private parseNumber(value: string | undefined): number | undefined {
    if (!value) return undefined;
    const cleaned = value.replace(/[^0-9.-]/g, '');
    const parsed = parseFloat(cleaned);
    return isNaN(parsed) ? undefined : parsed;
  }
  
  private extractHolders($: any): any[] {
    const holders: any[] = [];
    
    $('h3:contains("Holders"), h4:contains("Holders")').next('table').find('tbody tr').each((_, row) => {
      const $row = $(row);
      const holderName = $row.find('td:nth-child(1)').text().trim();
      const interest = $row.find('td:nth-child(2)').text().trim();
      
      if (holderName) {
        holders.push({ holderName, interest });
      }
    });
    
    return holders;
  }
  
  private extractSites($: any): any[] {
    const sites: any[] = [];
    
    $('h3:contains("Sites"), h4:contains("Sites")').next('table').find('tbody tr').each((_, row) => {
      const $row = $(row);
      const siteName = $row.find('td:nth-child(1)').text().trim();
      const siteCode = $row.find('td:nth-child(2)').text().trim();
      const siteType = $row.find('td:nth-child(3)').text().trim();
      
      if (siteName) {
        sites.push({ siteName, siteCode, siteType });
      }
    });
    
    return sites;
  }
  
  private extractProjects($: any): any[] {
    const projects: any[] = [];
    
    $('h3:contains("Projects"), h4:contains("Projects")').next('table').find('tbody tr').each((_, row) => {
      const $row = $(row);
      const projectName = $row.find('td:nth-child(1)').text().trim();
      const projectCode = $row.find('td:nth-child(2)').text().trim();
      
      if (projectName) {
        projects.push({ projectName, projectCode });
      }
    });
    
    return projects;
  }
  
  private extractProjectCodes($: any): string[] {
    const codes: string[] = [];
    
    $('h3:contains("Projects"), h4:contains("Projects")').next('table').find('tbody tr').each((_, row) => {
      const code = $(row).find('td:nth-child(2)').text().trim();
      if (code) codes.push(code);
    });
    
    return codes;
  }
  
  private extractEnvironmentalData($: any): any[] {
    return this.extractTableData($, 'Environmental');
  }
  
  private extractProductionData($: any): any[] {
    return this.extractTableData($, 'Production');
  }
  
  private extractInformationSources($: any): any[] {
    return this.extractTableData($, 'Information Sources');
  }
  
  private extractCoordinates($: any): any {
    // Extract coordinate data from various sources
    return {};
  }
  
  private extractGeologicalData($: any): any {
    return this.extractSectionData($, 'Geological');
  }
  
  private extractComplianceData($: any): any {
    return this.extractSectionData($, 'Compliance');
  }
  
  private extractProjectOwners($: any): any[] {
    return this.extractTableData($, 'Owners');
  }
  
  private extractProjectEvents($: any): any[] {
    return this.extractTableData($, 'Events');
  }
  
  private extractProjectAttachments($: any): any[] {
    return this.extractTableData($, 'Attachments');
  }
  
  private extractAlternativeNames($: any): string[] {
    const names: string[] = [];
    $('h3:contains("Alternative Names"), h4:contains("Alternative Names")').next().find('table tbody tr, li').each((_, element) => {
      const name = $(element).text().trim();
      if (name) names.push(name);
    });
    return names;
  }
  
  private extractProjectNotes($: any): string[] {
    const notes: string[] = [];
    $('h3:contains("Notes"), h4:contains("Notes")').next().find('table tbody tr, p, li').each((_, element) => {
      const note = $(element).text().trim();
      if (note) notes.push(note);
    });
    return notes;
  }
  
  private extractCommodityGroups($: any): string[] {
    return this.extractListData($, 'Commodities');
  }
  
  private extractTechnicalReports($: any): any[] {
    return this.extractTableData($, 'Technical Reports');
  }
  
  private extractMarketData($: any): any {
    return this.extractSectionData($, 'Market');
  }
  
  private extractInfrastructureData($: any): any {
    return this.extractSectionData($, 'Infrastructure');
  }
  
  private extractRiskAssessment($: any): any {
    return this.extractSectionData($, 'Risk');
  }
  
  // Generic helper methods
  private extractTableData($: any, sectionName: string): any[] {
    const data: any[] = [];
    
    $(`h3:contains("${sectionName}"), h4:contains("${sectionName}")`).next('table').find('tbody tr').each((_, row) => {
      const $row = $(row);
      const rowData: any = {};
      
      $row.find('td').each((index, cell) => {
        const cellText = $(cell).text().trim();
        if (cellText) {
          rowData[`field_${index}`] = cellText;
        }
      });
      
      if (Object.keys(rowData).length > 0) {
        data.push(rowData);
      }
    });
    
    return data;
  }
  
  private extractSectionData($: any, sectionName: string): any {
    const data: any = {};
    
    $(`h3:contains("${sectionName}"), h4:contains("${sectionName}")`).next().find('table tr, p, li').each((_, element) => {
      const text = $(element).text().trim();
      if (text) {
        // Try to extract key-value pairs
        const colonIndex = text.indexOf(':');
        if (colonIndex > 0) {
          const key = text.substring(0, colonIndex).trim().toLowerCase().replace(/\s+/g, '_');
          const value = text.substring(colonIndex + 1).trim();
          data[key] = value;
        } else {
          // Store as general information
          if (!data.general) data.general = [];
          data.general.push(text);
        }
      }
    });
    
    return data;
  }
  
  private extractListData($: any, sectionName: string): string[] {
    const items: string[] = [];
    
    $(`h3:contains("${sectionName}"), h4:contains("${sectionName}")`).next().find('table tbody tr, li, p').each((_, element) => {
      const text = $(element).text().trim();
      if (text && !items.includes(text)) {
        items.push(text);
      }
    });
    
    return items;
  }
}

export const comprehensiveMinedxScraper = new ComprehensiveMinedxScraper();
